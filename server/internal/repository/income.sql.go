// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: income.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addTagToIncome = `-- name: AddTagToIncome :exec
INSERT INTO income_tag_map (income_id, tag_id) VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type AddTagToIncomeParams struct {
	IncomeID pgtype.Int8 `json:"income_id"`
	TagID    pgtype.Int8 `json:"tag_id"`
}

func (q *Queries) AddTagToIncome(ctx context.Context, arg AddTagToIncomeParams) error {
	_, err := q.db.Exec(ctx, addTagToIncome, arg.IncomeID, arg.TagID)
	return err
}

const createIncome = `-- name: CreateIncome :one
INSERT INTO income (type_id, title, amount, account_id, purpose_id, notes, date, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, NOW(), NOW())
RETURNING id, type_id, title, amount, account_id, purpose_id, notes, date, created_at, updated_at
`

type CreateIncomeParams struct {
	TypeID    int32            `json:"type_id"`
	Title     string           `json:"title"`
	Amount    int64            `json:"amount"`
	AccountID int64            `json:"account_id"`
	PurposeID pgtype.Int8      `json:"purpose_id"`
	Notes     pgtype.Text      `json:"notes"`
	Date      pgtype.Timestamp `json:"date"`
}

func (q *Queries) CreateIncome(ctx context.Context, arg CreateIncomeParams) (Income, error) {
	row := q.db.QueryRow(ctx, createIncome,
		arg.TypeID,
		arg.Title,
		arg.Amount,
		arg.AccountID,
		arg.PurposeID,
		arg.Notes,
		arg.Date,
	)
	var i Income
	err := row.Scan(
		&i.ID,
		&i.TypeID,
		&i.Title,
		&i.Amount,
		&i.AccountID,
		&i.PurposeID,
		&i.Notes,
		&i.Date,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createIncomeTag = `-- name: CreateIncomeTag :one
INSERT INTO income_tag (name) VALUES ($1) RETURNING id, name
`

func (q *Queries) CreateIncomeTag(ctx context.Context, name string) (IncomeTag, error) {
	row := q.db.QueryRow(ctx, createIncomeTag, name)
	var i IncomeTag
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const createIncomeType = `-- name: CreateIncomeType :one
INSERT INTO income_type (name, description)
VALUES ($1, $2)
RETURNING id, name, description
`

type CreateIncomeTypeParams struct {
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) CreateIncomeType(ctx context.Context, arg CreateIncomeTypeParams) (IncomeType, error) {
	row := q.db.QueryRow(ctx, createIncomeType, arg.Name, arg.Description)
	var i IncomeType
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const deleteIncome = `-- name: DeleteIncome :exec
DELETE FROM income WHERE id = $1
`

func (q *Queries) DeleteIncome(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteIncome, id)
	return err
}

const deleteIncomeTag = `-- name: DeleteIncomeTag :exec
DELETE FROM income_tag WHERE id = $1
`

func (q *Queries) DeleteIncomeTag(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteIncomeTag, id)
	return err
}

const deleteIncomeType = `-- name: DeleteIncomeType :exec
DELETE FROM income_type WHERE id = $1
`

func (q *Queries) DeleteIncomeType(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteIncomeType, id)
	return err
}

const getIncome = `-- name: GetIncome :one
SELECT id, type_id, title, amount, account_id, purpose_id, notes, date, created_at, updated_at FROM income WHERE id = $1 LIMIT 1
`

func (q *Queries) GetIncome(ctx context.Context, id int64) (Income, error) {
	row := q.db.QueryRow(ctx, getIncome, id)
	var i Income
	err := row.Scan(
		&i.ID,
		&i.TypeID,
		&i.Title,
		&i.Amount,
		&i.AccountID,
		&i.PurposeID,
		&i.Notes,
		&i.Date,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getIncomeTag = `-- name: GetIncomeTag :one
SELECT id, name FROM income_tag WHERE id = $1 LIMIT 1
`

func (q *Queries) GetIncomeTag(ctx context.Context, id int64) (IncomeTag, error) {
	row := q.db.QueryRow(ctx, getIncomeTag, id)
	var i IncomeTag
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getIncomeType = `-- name: GetIncomeType :one
SELECT id, name, description FROM income_type WHERE id = $1 LIMIT 1
`

func (q *Queries) GetIncomeType(ctx context.Context, id int32) (IncomeType, error) {
	row := q.db.QueryRow(ctx, getIncomeType, id)
	var i IncomeType
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const listIncomeTags = `-- name: ListIncomeTags :many
SELECT id, name FROM income_tag ORDER BY id
`

func (q *Queries) ListIncomeTags(ctx context.Context) ([]IncomeTag, error) {
	rows, err := q.db.Query(ctx, listIncomeTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IncomeTag{}
	for rows.Next() {
		var i IncomeTag
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIncomeTypes = `-- name: ListIncomeTypes :many
SELECT id, name, description FROM income_type ORDER BY id
`

func (q *Queries) ListIncomeTypes(ctx context.Context) ([]IncomeType, error) {
	rows, err := q.db.Query(ctx, listIncomeTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IncomeType{}
	for rows.Next() {
		var i IncomeType
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIncomes = `-- name: ListIncomes :many
SELECT id, type_id, title, amount, account_id, purpose_id, notes, date, created_at, updated_at FROM income ORDER BY date DESC
`

func (q *Queries) ListIncomes(ctx context.Context) ([]Income, error) {
	rows, err := q.db.Query(ctx, listIncomes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Income{}
	for rows.Next() {
		var i Income
		if err := rows.Scan(
			&i.ID,
			&i.TypeID,
			&i.Title,
			&i.Amount,
			&i.AccountID,
			&i.PurposeID,
			&i.Notes,
			&i.Date,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTagsByIncome = `-- name: ListTagsByIncome :many
SELECT it.id, it.name FROM income_tag_map itm
JOIN income_tag it ON itm.tag_id = it.id
WHERE itm.income_id = $1
`

func (q *Queries) ListTagsByIncome(ctx context.Context, incomeID pgtype.Int8) ([]IncomeTag, error) {
	rows, err := q.db.Query(ctx, listTagsByIncome, incomeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IncomeTag{}
	for rows.Next() {
		var i IncomeTag
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeTagFromIncome = `-- name: RemoveTagFromIncome :exec
DELETE FROM income_tag_map WHERE income_id = $1 AND tag_id = $2
`

type RemoveTagFromIncomeParams struct {
	IncomeID pgtype.Int8 `json:"income_id"`
	TagID    pgtype.Int8 `json:"tag_id"`
}

func (q *Queries) RemoveTagFromIncome(ctx context.Context, arg RemoveTagFromIncomeParams) error {
	_, err := q.db.Exec(ctx, removeTagFromIncome, arg.IncomeID, arg.TagID)
	return err
}

const updateIncome = `-- name: UpdateIncome :one
UPDATE income
SET type_id = $2, title = $3, amount = $4, account_id = $5,
    purpose_id = $6, notes = $7, date = $8, updated_at = NOW()
WHERE id = $1
RETURNING id, type_id, title, amount, account_id, purpose_id, notes, date, created_at, updated_at
`

type UpdateIncomeParams struct {
	ID        int64            `json:"id"`
	TypeID    int32            `json:"type_id"`
	Title     string           `json:"title"`
	Amount    int64            `json:"amount"`
	AccountID int64            `json:"account_id"`
	PurposeID pgtype.Int8      `json:"purpose_id"`
	Notes     pgtype.Text      `json:"notes"`
	Date      pgtype.Timestamp `json:"date"`
}

func (q *Queries) UpdateIncome(ctx context.Context, arg UpdateIncomeParams) (Income, error) {
	row := q.db.QueryRow(ctx, updateIncome,
		arg.ID,
		arg.TypeID,
		arg.Title,
		arg.Amount,
		arg.AccountID,
		arg.PurposeID,
		arg.Notes,
		arg.Date,
	)
	var i Income
	err := row.Scan(
		&i.ID,
		&i.TypeID,
		&i.Title,
		&i.Amount,
		&i.AccountID,
		&i.PurposeID,
		&i.Notes,
		&i.Date,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateIncomeType = `-- name: UpdateIncomeType :one
UPDATE income_type
SET name = $2, description = $3
WHERE id = $1
RETURNING id, name, description
`

type UpdateIncomeTypeParams struct {
	ID          int32       `json:"id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) UpdateIncomeType(ctx context.Context, arg UpdateIncomeTypeParams) (IncomeType, error) {
	row := q.db.QueryRow(ctx, updateIncomeType, arg.ID, arg.Name, arg.Description)
	var i IncomeType
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}
