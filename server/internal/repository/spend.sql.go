// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: spend.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addTagToSpend = `-- name: AddTagToSpend :exec
INSERT INTO spend_tag_map (spend_id, tag_id) VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type AddTagToSpendParams struct {
	SpendID pgtype.Int8 `json:"spend_id"`
	TagID   pgtype.Int8 `json:"tag_id"`
}

func (q *Queries) AddTagToSpend(ctx context.Context, arg AddTagToSpendParams) error {
	_, err := q.db.Exec(ctx, addTagToSpend, arg.SpendID, arg.TagID)
	return err
}

const createSpend = `-- name: CreateSpend :one
INSERT INTO spend (type_id, title, amount, account_id, purpose_id, notes, date, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, NOW(), NOW())
RETURNING id, type_id, title, amount, account_id, purpose_id, notes, date, created_at, updated_at
`

type CreateSpendParams struct {
	TypeID    int32            `json:"type_id"`
	Title     string           `json:"title"`
	Amount    int64            `json:"amount"`
	AccountID int64            `json:"account_id"`
	PurposeID pgtype.Int8      `json:"purpose_id"`
	Notes     pgtype.Text      `json:"notes"`
	Date      pgtype.Timestamp `json:"date"`
}

func (q *Queries) CreateSpend(ctx context.Context, arg CreateSpendParams) (Spend, error) {
	row := q.db.QueryRow(ctx, createSpend,
		arg.TypeID,
		arg.Title,
		arg.Amount,
		arg.AccountID,
		arg.PurposeID,
		arg.Notes,
		arg.Date,
	)
	var i Spend
	err := row.Scan(
		&i.ID,
		&i.TypeID,
		&i.Title,
		&i.Amount,
		&i.AccountID,
		&i.PurposeID,
		&i.Notes,
		&i.Date,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSpendTag = `-- name: CreateSpendTag :one
INSERT INTO spend_tag (name) VALUES ($1) RETURNING id, name
`

func (q *Queries) CreateSpendTag(ctx context.Context, name string) (SpendTag, error) {
	row := q.db.QueryRow(ctx, createSpendTag, name)
	var i SpendTag
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const createSpendType = `-- name: CreateSpendType :one
INSERT INTO spend_type (name, description)
VALUES ($1, $2)
RETURNING id, name, description
`

type CreateSpendTypeParams struct {
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) CreateSpendType(ctx context.Context, arg CreateSpendTypeParams) (SpendType, error) {
	row := q.db.QueryRow(ctx, createSpendType, arg.Name, arg.Description)
	var i SpendType
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const deleteSpend = `-- name: DeleteSpend :exec
DELETE FROM spend WHERE id = $1
`

func (q *Queries) DeleteSpend(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteSpend, id)
	return err
}

const deleteSpendTag = `-- name: DeleteSpendTag :exec
DELETE FROM spend_tag WHERE id = $1
`

func (q *Queries) DeleteSpendTag(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteSpendTag, id)
	return err
}

const deleteSpendType = `-- name: DeleteSpendType :exec
DELETE FROM spend_type WHERE id = $1
`

func (q *Queries) DeleteSpendType(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteSpendType, id)
	return err
}

const getSpend = `-- name: GetSpend :one
SELECT id, type_id, title, amount, account_id, purpose_id, notes, date, created_at, updated_at FROM spend WHERE id = $1 LIMIT 1
`

func (q *Queries) GetSpend(ctx context.Context, id int64) (Spend, error) {
	row := q.db.QueryRow(ctx, getSpend, id)
	var i Spend
	err := row.Scan(
		&i.ID,
		&i.TypeID,
		&i.Title,
		&i.Amount,
		&i.AccountID,
		&i.PurposeID,
		&i.Notes,
		&i.Date,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSpendTag = `-- name: GetSpendTag :one
SELECT id, name FROM spend_tag WHERE id = $1 LIMIT 1
`

func (q *Queries) GetSpendTag(ctx context.Context, id int64) (SpendTag, error) {
	row := q.db.QueryRow(ctx, getSpendTag, id)
	var i SpendTag
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getSpendType = `-- name: GetSpendType :one
SELECT id, name, description FROM spend_type WHERE id = $1 LIMIT 1
`

func (q *Queries) GetSpendType(ctx context.Context, id int32) (SpendType, error) {
	row := q.db.QueryRow(ctx, getSpendType, id)
	var i SpendType
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const listSpendTags = `-- name: ListSpendTags :many
SELECT id, name FROM spend_tag ORDER BY id
`

func (q *Queries) ListSpendTags(ctx context.Context) ([]SpendTag, error) {
	rows, err := q.db.Query(ctx, listSpendTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SpendTag{}
	for rows.Next() {
		var i SpendTag
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSpendTypes = `-- name: ListSpendTypes :many
SELECT id, name, description FROM spend_type ORDER BY id
`

func (q *Queries) ListSpendTypes(ctx context.Context) ([]SpendType, error) {
	rows, err := q.db.Query(ctx, listSpendTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SpendType{}
	for rows.Next() {
		var i SpendType
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSpends = `-- name: ListSpends :many
SELECT id, type_id, title, amount, account_id, purpose_id, notes, date, created_at, updated_at FROM spend ORDER BY date DESC
`

func (q *Queries) ListSpends(ctx context.Context) ([]Spend, error) {
	rows, err := q.db.Query(ctx, listSpends)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Spend{}
	for rows.Next() {
		var i Spend
		if err := rows.Scan(
			&i.ID,
			&i.TypeID,
			&i.Title,
			&i.Amount,
			&i.AccountID,
			&i.PurposeID,
			&i.Notes,
			&i.Date,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTagsBySpend = `-- name: ListTagsBySpend :many
SELECT st.id, st.name FROM spend_tag_map stm
JOIN spend_tag st ON stm.tag_id = st.id
WHERE stm.spend_id = $1
`

func (q *Queries) ListTagsBySpend(ctx context.Context, spendID pgtype.Int8) ([]SpendTag, error) {
	rows, err := q.db.Query(ctx, listTagsBySpend, spendID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SpendTag{}
	for rows.Next() {
		var i SpendTag
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeTagFromSpend = `-- name: RemoveTagFromSpend :exec
DELETE FROM spend_tag_map WHERE spend_id = $1 AND tag_id = $2
`

type RemoveTagFromSpendParams struct {
	SpendID pgtype.Int8 `json:"spend_id"`
	TagID   pgtype.Int8 `json:"tag_id"`
}

func (q *Queries) RemoveTagFromSpend(ctx context.Context, arg RemoveTagFromSpendParams) error {
	_, err := q.db.Exec(ctx, removeTagFromSpend, arg.SpendID, arg.TagID)
	return err
}

const updateSpend = `-- name: UpdateSpend :one
UPDATE spend
SET type_id = $2, title = $3, amount = $4, account_id = $5,
    purpose_id = $6, notes = $7, date = $8, updated_at = NOW()
WHERE id = $1
RETURNING id, type_id, title, amount, account_id, purpose_id, notes, date, created_at, updated_at
`

type UpdateSpendParams struct {
	ID        int64            `json:"id"`
	TypeID    int32            `json:"type_id"`
	Title     string           `json:"title"`
	Amount    int64            `json:"amount"`
	AccountID int64            `json:"account_id"`
	PurposeID pgtype.Int8      `json:"purpose_id"`
	Notes     pgtype.Text      `json:"notes"`
	Date      pgtype.Timestamp `json:"date"`
}

func (q *Queries) UpdateSpend(ctx context.Context, arg UpdateSpendParams) (Spend, error) {
	row := q.db.QueryRow(ctx, updateSpend,
		arg.ID,
		arg.TypeID,
		arg.Title,
		arg.Amount,
		arg.AccountID,
		arg.PurposeID,
		arg.Notes,
		arg.Date,
	)
	var i Spend
	err := row.Scan(
		&i.ID,
		&i.TypeID,
		&i.Title,
		&i.Amount,
		&i.AccountID,
		&i.PurposeID,
		&i.Notes,
		&i.Date,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSpendType = `-- name: UpdateSpendType :one
UPDATE spend_type
SET name = $2, description = $3
WHERE id = $1
RETURNING id, name, description
`

type UpdateSpendTypeParams struct {
	ID          int32       `json:"id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) UpdateSpendType(ctx context.Context, arg UpdateSpendTypeParams) (SpendType, error) {
	row := q.db.QueryRow(ctx, updateSpendType, arg.ID, arg.Name, arg.Description)
	var i SpendType
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}
